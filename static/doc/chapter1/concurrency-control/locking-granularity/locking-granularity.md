##### 1.2.2 锁粒度

一种提高共享资源并发性的方式就是让锁定对象更有选择性。
尽量只锁定需要修改的部分数据,而不思所有的资源。
更理想的方式是,只对会修改的数据片进行精确的锁定。
任何时候,在给定的资源上,锁定的数据量越少,
则系统的并发程度越高,只要相互之间不发生冲突即可。

问题是加锁也需要消耗资源。
锁的各种操作,包括获得锁、检查锁是否已经解锁,释放等,
都会增加系统的开销。
如果系统花费大量的时间来管理锁,而不是存储数据,
那么系统的性能可能因此受到影响。

所谓的锁策略,就是在锁的开销和数据的安全性之间寻求平衡,
这种平衡当然也会影响到性能。
大多数商业数据库系统没有提供更多的选择,
一般都是在表上施加行级锁(row-level lock)，
并以各种复杂的方式来实现,
以便在锁比较多的情况下尽可能地提供更好的性能。

而MySQL则提供了多种选择。
每种MySQL存储引擎都可以实现自己的锁策略和锁粒度。
在存储引擎的设计中,锁管理是个非常重要的决定。
将锁粒度固定在某个级别,可以为某些特定的应用场景提供更好的性能,
但同时却会失去对另外一些应用场景的良好支持。
好在MySQL支持多个存储引擎的架构,
所有不需要单一的通用解决方案。

###### 表锁(table lock)

表锁是MySQL中最基本的锁策略,
并且是开销最小的策略。
表锁是MySQL中最基本的锁策略,并且开销最小的策略。
表锁非常类似于前文描述的邮箱加锁机制：它会锁定整张表。
一个用户在对表进行写操作(插入、删除、更新等)前,
需要先获得写锁,这会阻塞其他用户对该表的所有读写操作。
只是没有写锁时,其他读取的用户才能获得读锁,
读锁之间是不相互阻塞的。

在特定的场景中,表锁也可能有良好的性能。
例如, **READ LOCAL** 表锁支持某些类型的并发写操作。
另外,写锁也比读锁有更高的优先级,
因此一个写锁请求可能会被插入到读锁队列的前面
(写锁可以插入到锁队列中读锁的前面,反之读锁则不能插入到写锁的前面)。

尽管存储引擎可以管理自己的锁,
MySQL本身还是会使用各种有效的表锁来实现不同的目的。
例如,服务器会为诸如 **ALERT TABLE**之类的语句使用表锁,
而忽略存储引擎的锁机制。

###### 行级锁(row lock)

行级锁可以最大程度地支持并发处理(同时也带来了最大的锁开销)。
众所周知,在InnoDB和XtraDB,以及其他一些存储引擎中实现了行级锁。
行级锁只在存储引擎层实现,而MySQL服务器层没有实现。
服务器层完全不了解存储引擎中的锁实现。








